"""
CORVA AGNO AGENT - VERSI√ìN AVATAR CORREGIDA CON INTEGRACI√ìN COMPLETA
====================================================================

Soluci√≥n robusta que maneja correctamente el flujo:
1. Buscar asset_id
2. Validar match exacto  
3. Ejecutar consulta espec√≠fica

MANTIENE INTEGRACI√ìN COMPLETA CON SISTEMA AVATAR
"""

import os
import asyncio
import json
import uuid
import time
from typing import Dict, List, Optional, Any, Tuple
from agno.agent import Agent
from agno.models.azure import AzureOpenAI
from agno.tools import tool

# üîß IMPORTAR FUNCIONES EXISTENTES CON RUTA AVATAR CORRECTA
try:
    from src.corva_tool import (
        # Funciones principales existentes
        make_corva_request_fixed,
        classify_user_intent,
        extract_asset_name,
        search_asset_by_name,
        get_alerts,
        get_rigs,
        get_wells,
        get_assets_general,
        get_kpis_workflow,
        format_response_for_agent,
        CorvaAPIError,
        get_wits_depth,
        get_wits_summary,
        get_metrics_rop,
        get_operations,
        
        # NUEVAS FUNCIONES A AGREGAR:
        get_asset_detailed_info,      # ‚Üê NUEVA
        get_fracking_metrics,           # ‚Üê NUEVA
        format_fracking_metrics_response,  # ‚Üê NUEVA
        
        # Funciones auxiliares (mantener existentes)
        normalize_asset_name_for_matching,
        calculate_smart_similarity
    )
except ImportError as e:
    print(f"‚ö†Ô∏è Error al importar funciones de corva_tool_avatar: {e}")
    raise

# üîß IMPORTAR MEMORIA AVATAR SI EST√Å DISPONIBLE
try:
    from src.langmem_functions import (
        get_relevant_context_for_question, 
        create_enhanced_prompt_with_memory,
        get_user_preferences_and_patterns
    )
    MEMORY_AVAILABLE = True
except ImportError:
    MEMORY_AVAILABLE = False

try:
    from src.postgres_integration import (
        save_complete_memory, save_performance_metric_simple
    )
    POSTGRES_AVAILABLE = True
except ImportError:
    POSTGRES_AVAILABLE = False


def validate_azure_env_vars_avatar() -> Tuple[bool, List[str]]:
    """
    Valida que todas las variables de entorno necesarias para Avatar Azure est√©n configuradas
    
    Returns:
        tuple[bool, list[str]]: (es_v√°lido, variables_faltantes)
    """
    # Variables requeridas para Avatar
    required_vars = [
        "AZURE_OPENAI_API_KEY",
        "AZURE_OPENAI_ENDPOINT", 
    ]
    
    # Para deployment Avatar, usar la variable est√°ndar
    deployment_var = "AZURE_OPENAI_DEPLOYMENT_NAME"  # ‚Üê Variable Avatar est√°ndar
    api_version_var = "API_VERSION"  # ‚Üê Variable Avatar est√°ndar
    
    missing_vars = []
    configured_vars = []
    
    # Validar variables b√°sicas
    for var in required_vars:
        value = os.getenv(var)
        if not value or value.strip() == "":
            missing_vars.append(var)
        else:
            configured_vars.append(var)
    
    # Validar deployment Avatar
    deployment_value = os.getenv(deployment_var)
    if not deployment_value or deployment_value.strip() == "":
        missing_vars.append(deployment_var)
    else:
        configured_vars.append(deployment_var)
    
    # Validar API version Avatar
    api_version_value = os.getenv(api_version_var, "2024-10-21")  # Default Avatar
    if api_version_value:
        configured_vars.append(api_version_var)
    
    if missing_vars:
        print(f"‚ùå Variables Avatar Azure faltantes: {missing_vars}")
        if configured_vars:
            print(f"‚úÖ Variables Avatar Azure configuradas: {configured_vars}")
        return False, missing_vars
    
    print("‚úÖ Todas las variables Avatar Azure est√°n configuradas correctamente")
    return True, []


class CorvaAgnoAgent:
    """
    Agente ReAct para plataforma Corva - VERSI√ìN AVATAR COMPLETA
    
    MANTIENE INTEGRACI√ìN COMPLETA CON:
    - Sistema de memoria Avatar
    - PostgreSQL Avatar
    - Variables de entorno Avatar
    - Estructura de proyecto Avatar
    """
    
    def __init__(self):
        """Inicializaci√≥n robusta con validaciones Avatar"""
        
        # Estado de inicializaci√≥n Avatar
        self.agent = None
        self.initialization_status = "No inicializado"
        
        try:
            # Verificar variables Avatar necesarias
            if not os.getenv("APIM_AUTH_CREDENTIAL"):
                raise ValueError("APIM_AUTH_CREDENTIAL no encontrada")
            
            # Verificar variables Avatar Azure
            is_valid, missing_vars = validate_azure_env_vars_avatar()
            if not is_valid:
                raise ValueError(f"Variables Avatar Azure faltantes: {missing_vars}")
                
            deployment_name = os.getenv('AZURE_OPENAI_DEPLOYMENT_NAME')  # ‚Üê Variable Avatar est√°ndar
            if not deployment_name:
                raise ValueError("AZURE_OPENAI_DEPLOYMENT_NAME no encontrada")
            
            print(f"üîß Inicializando Agno Avatar robusto con deployment: {deployment_name}")
            
            # ‚úÖ CONFIGURACI√ìN AVATAR CORREGIDA
            azure_model = AzureOpenAI(
                id=deployment_name,
                api_key=os.getenv("AZURE_OPENAI_API_KEY"),
                api_version=os.getenv("API_VERSION", "2024-10-21"),  # ‚Üê Variable Avatar est√°ndar
                azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
            )
            
            self.agent = Agent(
                name="CorvaExpertAvatar",
                role="Especialista en datos de Corva con integraci√≥n completa Avatar",
                model=azure_model,
                tools=[
                    self._create_alerts_tool(),            # üì¢ CONSULTAS GENERALES
                    self._create_rigs_tool(),
                    self._create_wells_tool(),
                    self._create_assets_general_tool(),
                    self._create_asset_search_tool(),      # üîç B√öSQUEDA INTELIGENTE
                    self._create_asset_detailed_info_tool(),  # ‚Üê NUEVA TOOL
                    self._create_kpis_tool(),              # üìä DATOS ESPEC√çFICOS
                    self._create_wits_depth_tool(),
                    self._create_wits_summary_tool(), 
                    self._create_metrics_rop_tool(),
                    self._create_operations_tool(),
                    self._create_fracking_metrics_tool(),  # ‚Üê NUEVA TOOL
                ],
                instructions=self._create_avatar_instructions(),
                description="Agente ReAct para plataforma de datos en tiempo real YPF - AVATAR COMPLETO",
                markdown=True,
                show_tool_calls=False,
                debug_mode=False  # ‚Üê Avatar no necesita debug visible
            )
            
            self.initialization_status = "‚úÖ Agente Corva Avatar completo inicializado correctamente"
            print(self.initialization_status)
            
        except Exception as e:
            self.initialization_status = f"‚ùå Error inicializando agente Avatar: {str(e)}"
            print(self.initialization_status)
            raise

    def _create_avatar_instructions(self) -> List[str]:
        """üîß Instrucciones Avatar optimizadas para integraci√≥n completa ACTUALIZADAS"""
        
        return ["""
        ## AGENTE CORVA AVATAR - CADENA DE RAZONAMIENTO COMPLETA (CoT) ACTUALIZADA
        
        Eres un agente ReAct experto en datos de Corva para la industria de petr√≥leo y gas, 
        integrado completamente con el sistema Avatar de YPF.

        ### PASO 1: AN√ÅLISIS DE INTENCI√ìN AUTOM√ÅTICO
        Analiza autom√°ticamente la consulta del usuario y clasifica la intenci√≥n:
        1. ¬øEs una consulta general? ‚Üí Usar tools directas (alerts, rigs, wells, assets general)
        2. ¬øPide INFORMACI√ìN COMPLETA/DETALLADA de un asset? ‚Üí fetch_asset_detailed_info()
        3. ¬øMenciona m√©tricas de FRACTURAMIENTO? ‚Üí fetch_fracking_metrics()
        4. ¬øMenciona un asset espec√≠fico + datos operacionales? ‚Üí Proceder al PASO 2
        5. ¬øRequiere datos espec√≠ficos de un asset? ‚Üí Proceder al PASO 2

        ### PASO 2: B√öSQUEDA Y VALIDACI√ìN DE ASSET (OBLIGATORIO para datos espec√≠ficos)
        **ANTES de obtener datos operacionales espec√≠ficos:**
        1. Usar search_specific_asset() para buscar el asset
        2. **VALIDACI√ìN INTELIGENTE**: Las funciones de datos ya manejan matching autom√°tico
        3. Solo mostrar opciones al usuario si hay ambig√ºedad real
        4. Proceder autom√°ticamente con matches de alta similitud (85%+)

        ### PASO 3: TIPOS DE INFORMACI√ìN DISPONIBLE
        
        **INFORMACI√ìN BASE/COMPLETA (usar fetch_asset_detailed_info):**
        - Metadata del asset (ID, nombre, tipo, compa√±√≠a)
        - Informaci√≥n del rig asociado (nombre, contratista)
        - Estado y actividad (√∫ltima actividad, estado)
        - Ubicaci√≥n y coordenadas
        - Configuraci√≥n t√©cnica base
        - Fechas importantes (creaci√≥n, spud, completion)
        
        **M√âTRICAS DE FRACTURAMIENTO (usar fetch_fracking_metrics):**
        - Vol√∫menes de fluidos por etapa (sucio, limpio)
        - Qu√≠micos l√≠quidos (reductor fricci√≥n, surfactante, biocida, inhibidor, martillo l√≠quido)
        - Qu√≠micos en polvo (concentraci√≥n FR, triturador, gel)
        - Proppant (arena) total por etapa
        - Tiempos de operaci√≥n entre etapas
        
        **DATOS OPERACIONALES EN TIEMPO REAL (usar tools espec√≠ficas):**
        - KPIs de rendimiento ‚Üí fetch_asset_kpis()
        - Profundidad actual ‚Üí fetch_wits_depth()
        - ROP en tiempo real ‚Üí fetch_wits_summary()
        - M√©tricas hist√≥ricas ‚Üí fetch_metrics_rop()
        - Tiempos de operaci√≥n ‚Üí fetch_operations()

        ### EJEMPLOS DE CLASIFICACI√ìN ACTUALIZADA:

        ‚ùì "Dame informaci√≥n del DLS 168" ‚Üí fetch_asset_detailed_info()
        ‚ùì "Detalles completos del LCav-415" ‚Üí fetch_asset_detailed_info()  
        ‚ùì "Qu√© sabes sobre el pozo ABC-001" ‚Üí fetch_asset_detailed_info()
        ‚ùì "Informaci√≥n base del rig F35" ‚Üí fetch_asset_detailed_info()

        ‚ùì "volumen sucio del LCav-415" ‚Üí fetch_fracking_metrics()
        ‚ùì "reductor de fricci√≥n del DLS 168" ‚Üí fetch_fracking_metrics() 
        ‚ùì "arena total del pozo ABC-001" ‚Üí fetch_fracking_metrics()
        ‚ùì "tiempo entre etapas del LCav-415" ‚Üí fetch_fracking_metrics()
        ‚ùì "qu√≠micos del pozo ABC-001 etapa 5" ‚Üí fetch_fracking_metrics()

        ‚ùì "KPIs del DLS 168" ‚Üí search_specific_asset() + fetch_asset_kpis()
        ‚ùì "profundidad actual del LCav-415" ‚Üí fetch_wits_depth()
        ‚ùì "ROP del pozo ABC-001" ‚Üí fetch_wits_summary()

        ### REGLAS CR√çTICAS DE VALIDACI√ìN ACTUALIZADAS:
        - **fetch_asset_detailed_info() NO requiere search_specific_asset() previo** (tiene su propio matching)
        - **fetch_fracking_metrics() NO requiere search_specific_asset() previo** (tiene su propio matching)
        - **Para datos operacionales S√ç usar search_specific_asset() primero**
        - **SIEMPRE mostrar opciones cuando hay m√∫ltiples candidatos**

        ### INTEGRACI√ìN AVATAR:
        - Mant√©n respuestas profesionales pero accesibles
        - Usa emojis apropiados para claridad visual
        - Estructura informaci√≥n de manera clara para el usuario Avatar
        - Aprovecha el matching autom√°tico inteligente integrado
        
        ### MANEJO DE ERRORES AVATAR:
        - Si hay errores de API, explica claramente el problema
        - Sugiere alternativas cuando sea posible
        - Mant√©n un tono profesional pero cercano
        - Formatea los resultados de manera clara y estructurada
        
        ### CONVERSIONES IMPORTANTES PARA AVATAR:
        - **Profundidad**: Si hay valores en feet/pies/ft, convertir al sistema m√©trico multiplicando por 0.3048 y expresar en metros
        - **Tiempo**: Los valores de fetch_operations() est√°n en SEGUNDOS, NO en minutos
        """]

    def _create_alerts_tool(self):
        """üì¢ Tool para obtener alertas generales"""
        @tool
        def fetch_corva_alerts() -> str:
            """
            Obtiene todas las alertas generales disponibles en Corva.
            √ösala cuando el usuario pregunte por alertas, alarmas o notificaciones.
            
            Returns:
                str: Informaci√≥n formateada de las alertas encontradas
            """
            try:
                result = get_alerts()
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo alertas: {error_msg}"
            except Exception as e:
                return f"Error al obtener alertas: {str(e)}"
        
        return fetch_corva_alerts
    
    def _create_rigs_tool(self):
        """üîß Tool para obtener informaci√≥n general de rigs"""
        @tool  
        def fetch_corva_rigs() -> str:
            """
            Obtiene informaci√≥n general de todos los rigs disponibles en Corva.
            √ösala cuando el usuario pregunte por equipos, rigs o perforadoras en general.
            
            Returns:
                str: Lista formateada de rigs disponibles
            """
            try:
                result = get_rigs()
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo rigs: {error_msg}"
            except Exception as e:
                return f"Error al obtener rigs: {str(e)}"
        
        return fetch_corva_rigs
    
    def _create_wells_tool(self):
        """üè≠ Tool para obtener informaci√≥n general de wells"""
        @tool
        def fetch_corva_wells() -> str:
            """
            Obtiene informaci√≥n general de todos los wells (pozos) disponibles en Corva.
            √ösala cuando el usuario pregunte por pozos, wells en general.
            
            Returns:
                str: Lista formateada de wells disponibles  
            """
            try:
                result = get_wells()
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo wells: {error_msg}"
            except Exception as e:
                return f"Error al obtener wells: {str(e)}"
        
        return fetch_corva_wells
    
    def _create_assets_general_tool(self):
        """üìã Tool para obtener informaci√≥n general de assets"""
        @tool
        def fetch_general_assets() -> str:
            """
            Obtiene informaci√≥n general de todos los assets (rigs y wells) disponibles.
            √ösala cuando el usuario pregunte por assets en general, listado completo de equipos o pozos.
            
            Returns:
                str: Lista formateada de todos los assets disponibles
            """
            try:
                result = get_assets_general()
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo assets generales: {error_msg}"
            except Exception as e:
                return f"Error al obtener assets generales: {str(e)}"
        
        return fetch_general_assets
    
    def _create_asset_search_tool(self):
        """üîç Tool de b√∫squeda de assets SIN cache problem√°tico"""
        @tool
        def search_specific_asset(asset_name: str) -> str:
            """
            Busca un asset espec√≠fico (rig o well) por nombre en la base de datos de Corva.
            
            Esta funci√≥n usa matching inteligente autom√°tico:
            - Match exacto (98%+): Procede autom√°ticamente
            - Match bueno (85-97%): Informa similitud pero permite uso
            - Match bajo (<85%): Solicita validaci√≥n del usuario
            
            Args:
                asset_name: Nombre exacto o aproximado del asset a buscar
                
            Returns:
                str: Asset encontrado o lista de opciones para validaci√≥n del usuario
            """
            try:
                clean_name = str(asset_name).strip() if asset_name else ""
                if not clean_name:
                    return "‚ö†Ô∏è No se proporcion√≥ un nombre v√°lido de asset."
                
                print(f"üîç BUSCANDO ASSET AVATAR: '{clean_name}'")
                
                matches, search_type = search_asset_by_name(clean_name)
                
                print(f"üîç RESULTADO AVATAR: {search_type}, {len(matches)} matches")
                
                if search_type == "exact":
                    if len(matches) == 1:
                        asset = matches[0]
                        name = asset.get("attributes", {}).get("name", "")
                        asset_id = asset.get("id", "")
                        return f"‚úÖ Asset encontrado: '{name}' (ID: {asset_id})\n\n‚úÖ Puedes proceder con KPIs, profundidad, ROP, etc."
                    
                    else:  # M√∫ltiples matches exactos
                        # Buscar el que coincida EXACTAMENTE
                        for asset in matches:
                            asset_name_field = asset.get("attributes", {}).get("name", "")
                            if asset_name_field.strip().lower() == clean_name.strip().lower():
                                asset_id = asset.get("id", "")
                                return f"‚úÖ Asset encontrado: '{asset_name_field}' (ID: {asset_id})\n\n‚úÖ Puedes proceder con KPIs, profundidad, etc."
                        
                        # Si no encuentra coincidencia exacta en m√∫ltiples
                        results = ["üîç Encontr√© m√∫ltiples assets similares:"]
                        for i, asset in enumerate(matches[:5], 1):
                            name = asset.get("attributes", {}).get("name", "")
                            results.append(f"{i}. {name}")
                        results.append("\n‚ùì ¬øCu√°l necesitas? Especifica el nombre exacto.")
                        return "\n".join(results)
                
                elif search_type == "partial":
                    results = [f"üîç No encontr√© '{clean_name}' exactamente. Assets similares:"]
                    for i, asset in enumerate(matches[:5], 1):
                        name = asset.get("attributes", {}).get("name", "")
                        similarity = asset.get("similarity", 0)
                        results.append(f"{i}. {name} (similitud: {similarity:.0f}%)")
                    results.append(f"\n‚ùì ¬øEs '{clean_name}' alguno de estos? Las funciones de datos pueden usar el mejor match autom√°ticamente.")
                    return "\n".join(results)
                
                elif search_type == "none":
                    return f"‚ùå NO encontrado: '{clean_name}'\n\nüí° Usa fetch_general_assets() para ver todos los assets disponibles."
                
                else:
                    return f"‚ö†Ô∏è Error buscando '{clean_name}'"
                    
            except Exception as e:
                print(f"‚ùå ERROR B√öSQUEDA AVATAR: {e}")
                return f"‚ùå Error: {str(e)}"
        
        return search_specific_asset

    def _create_kpis_tool(self):
        """üìä HERRAMIENTA DE KPIs SIN DEPENDENCIAS DE CACHE"""
        @tool
        def fetch_asset_kpis(user_query: str) -> str:
            """
            Obtiene KPIs espec√≠ficos para un rig o well mencionado en la consulta del usuario.
            
            Esta herramienta usa matching autom√°tico inteligente integrado:
            - No requiere validaci√≥n previa obligatoria
            - Maneja autom√°ticamente matches de alta similitud (85%+)
            - Solo solicita aclaraci√≥n si hay ambig√ºedad real
            
            Args:
                user_query: Consulta del usuario que incluye el nombre del rig o well
                
            Returns:
                str: KPIs formateados del asset encontrado
                
            Ejemplos de uso:
            - "KPIs del rig DLS 167"
            - "datos de rendimiento del well ABC-001"
            """
            try:
                print(f"üìä OBTENIENDO KPIs AVATAR: '{user_query}'")
                
                # La funci√≥n get_kpis_workflow ya maneja el matching inteligente
                result = get_kpis_workflow(user_query)
                
                if result and result.get("success"):
                    formatted_result = format_response_for_agent(result)
                    print("‚úÖ KPIs Avatar obtenidos exitosamente")
                    return formatted_result
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    print(f"‚ö†Ô∏è Error KPIs Avatar: {error_msg}")
                    return f"‚ö†Ô∏è Error obteniendo KPIs: {error_msg}"
                    
            except Exception as e:
                error_msg = str(e)
                print(f"‚ùå ERROR EN KPIs AVATAR: {error_msg}")
                if "Expecting value" in error_msg:
                    return "‚ö†Ô∏è El endpoint de KPIs est√° disponible pero devolvi√≥ una respuesta vac√≠a."
                return f"Error al obtener KPIs: {error_msg}"
        
        return fetch_asset_kpis

    def _create_wits_depth_tool(self):
        """üéØ HERRAMIENTA DE PROFUNDIDAD SIN DEPENDENCIAS"""
        @tool
        def fetch_wits_depth(user_query: str) -> str:
            """
            Obtiene profundidad del trepano de un asset espec√≠fico.
            
            Usa matching autom√°tico inteligente integrado.
            
            Args:
                user_query: Consulta que incluye el nombre del rig o well
                
            Returns:
                str: Profundidad del hueco y del trepano formateada
            """
            try:
                print(f"üéØ OBTENIENDO PROFUNDIDAD AVATAR: '{user_query}'")
                
                result = get_wits_depth(user_query)
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo profundidad: {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener profundidad del trepano: {str(e)}"
        
        return fetch_wits_depth

    def _create_wits_summary_tool(self):
        """üìè HERRAMIENTA DE ROP SIN DEPENDENCIAS"""
        @tool
        def fetch_wits_summary(user_query: str) -> str:
            """
            Obtiene el ROP actual del pozo para un asset espec√≠fico.
            
            Usa matching autom√°tico inteligente integrado.
            
            Args:
                user_query: Consulta que incluye el nombre del rig o well
                
            Returns:
                str: ROP actual formateado
            """
            try:
                print(f"üìè OBTENIENDO ROP AVATAR: '{user_query}'")
                
                result = get_wits_summary(user_query)
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo ROP actual: {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener ROP actual: {str(e)}"
        
        return fetch_wits_summary

    def _create_metrics_rop_tool(self):
        """üìä HERRAMIENTA DE M√âTRICAS ROP SIN DEPENDENCIAS"""
        @tool
        def fetch_metrics_rop(user_query: str) -> str:
            """
            Obtiene m√©tricas de ROP promedio por secci√≥n del pozo.
            
            Usa matching autom√°tico inteligente integrado.
            
            Args:
                user_query: Consulta que incluye el nombre del rig or well
                
            Returns:
                str: M√©tricas ROP formateadas por secci√≥n
            """
            try:
                print(f"üìä OBTENIENDO M√âTRICAS ROP AVATAR: '{user_query}'")
                
                result = get_metrics_rop(user_query)
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo m√©tricas ROP: {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener m√©tricas ROP: {str(e)}"
        
        return fetch_metrics_rop

    def _create_operations_tool(self):
        """‚è±Ô∏è HERRAMIENTA DE OPERACIONES SIN DEPENDENCIAS"""
        @tool
        def fetch_operations(user_query: str) -> str:
            """
            Obtiene tiempos de operaciones de conexi√≥n para un asset espec√≠fico.
            
            Usa matching autom√°tico inteligente integrado.
            
            Args:
                user_query: Consulta que incluye el nombre del rig o well
                
            Returns:
                str: Tiempos de operaciones formateados
            """
            try:
                print(f"‚è±Ô∏è OBTENIENDO OPERACIONES AVATAR: '{user_query}'")
                
                result = get_operations(user_query)
                if result and result.get("success"):
                    return format_response_for_agent(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo operaciones: {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener operaciones: {str(e)}"
        
        return fetch_operations
    
    def _create_asset_detailed_info_tool(self):
        """üîß Tool para obtener informaci√≥n completa y detallada de un asset espec√≠fico"""
        @tool
        def fetch_asset_detailed_info(user_query: str) -> str:
            """
            Obtiene informaci√≥n completa y detallada de un asset espec√≠fico (rig o well).
            
            Esta tool est√° dise√±ada para responder consultas como:
            - "Dame informaci√≥n del DLS 168"
            - "Detalles completos del LCav-415"
            - "Informaci√≥n del rig Nabors F35"
            - "Datos completos del pozo YPF.Nq.LCav-415(h)"
            - "Qu√© sabes sobre el asset ABC-001"
            
            IMPORTANTE: Esta tool devuelve informaci√≥n DE BASE del asset (metadata, configuraci√≥n,
            ubicaci√≥n, estado, etc.) NO datos operacionales en tiempo real.
            
            Para datos operacionales espec√≠ficos usa:
            - fetch_asset_kpis() ‚Üí KPIs y rendimiento
            - fetch_wits_depth() ‚Üí Profundidad del trepano  
            - fetch_wits_summary() ‚Üí ROP actual
            
            Args:
                user_query: Consulta del usuario que incluye el nombre del asset
                
            Returns:
                str: Informaci√≥n completa formateada del asset encontrado
                
            Ejemplos de uso:
            - "informaci√≥n completa del DLS 168"
            - "detalles del pozo LCav-415"
            - "datos base del rig F35"
            """
            try:
                result = get_asset_detailed_info(user_query)
                
                if result and result.get("success"):
                    # Extraer la informaci√≥n formateada
                    detailed_info = result.get("detailed_info", "")
                    asset_name = result.get("asset_name", "")
                    message = result.get("message", "")
                    
                    if detailed_info:
                        return f"{message}\n\n{detailed_info}"
                    else:
                        return f"‚úÖ Asset encontrado: {asset_name}, pero no se pudo formatear la informaci√≥n completa."
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è Error obteniendo informaci√≥n detallada: {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener informaci√≥n detallada del asset: {str(e)}"
        
        return fetch_asset_detailed_info

    def _create_fracking_metrics_tool(self):
        """üìä Tool para obtener m√©tricas de fracturamiento hidr√°ulico"""
        @tool
        def fetch_fracking_metrics(user_query: str) -> str:
            """
            Obtiene m√©tricas espec√≠ficas de fracturamiento hidr√°ulico para un asset.
            
            Esta tool maneja m√©tricas agregadas por etapa para operaciones de fracking:
            
            **VOL√öMENES:**
            - Volumen sucio/limpio por etapa
            
            **QU√çMICOS L√çQUIDOS:**
            - Reductor de fricci√≥n
            - Surfactante  
            - Biocida
            - Inhibidor de escala
            - Martillo l√≠quido
            
            **QU√çMICOS EN POLVO:**
            - Concentraci√≥n de polvo FR
            - Triturador de polvo
            - Gel en polvo
            
            **PROPPANT Y TIMING:**
            - Arena total (proppant)
            - Tiempo entre etapas
            
            IMPORTANTE: Esta tool incluye su propia b√∫squeda y validaci√≥n de assets.
            
            Args:
                user_query: Consulta que incluye el asset y tipo de m√©trica deseada
                
            Returns:
                str: M√©tricas de fracturamiento formateadas por etapa
                
            Ejemplos de uso:
            - "volumen sucio del pozo LCav-415"
            - "reductor de fricci√≥n del rig DLS-168"
            - "arena total por etapa del well ABC-001"
            - "tiempo entre etapas del LCav-415 etapa 5"
            """
            try:
                result = get_fracking_metrics(user_query)
                
                if result and result.get("success"):
                    return format_fracking_metrics_response(result)
                else:
                    error_msg = result.get("error", "Error desconocido") if result else "Respuesta vac√≠a"
                    return f"‚ö†Ô∏è {error_msg}"
                    
            except Exception as e:
                return f"Error al obtener m√©tricas de fracturamiento: {str(e)}"
        
        return fetch_fracking_metrics

    def get_status_info(self) -> str:
        """Devuelve informaci√≥n del estado de inicializaci√≥n Avatar"""
        return self.initialization_status

    def process_query(self, user_query: str, session_id: str = None, user_id: str = None) -> str:
        """
        Procesador Avatar sin cache problem√°tico y con integraci√≥n completa
        
        INTEGRACI√ìN AVATAR:
        - Acepta session_id y user_id para integraci√≥n con sistema Avatar
        - Maneja memoria Avatar si est√° disponible
        - Guarda m√©tricas en PostgreSQL Avatar
        """
        try:
            if not user_query or not user_query.strip():
                return "‚ö†Ô∏è Consulta vac√≠a"
            
            clean_query = user_query.strip()
            
            if not self.agent:
                return f"‚ùå Agente Avatar no inicializado: {self.initialization_status}"
            
            print(f"üöÄ PROCESANDO AVATAR: '{clean_query}'")
            
            # üîß INTEGRACI√ìN MEMORIA AVATAR
            enhanced_query = clean_query
            if MEMORY_AVAILABLE and session_id and user_id:
                try:
                    # Enriquecer query con contexto Avatar
                    relevant_context = get_relevant_context_for_question(clean_query, user_id, session_id)
                    if relevant_context:
                        enhanced_query = f"{clean_query}\n\nContexto Avatar relevante:\n{relevant_context[:300]}..."
                        print(f"‚úÖ Contexto Avatar agregado: {len(relevant_context)} chars")
                except Exception as context_error:
                    print(f"‚ö†Ô∏è Error obteniendo contexto Avatar: {context_error}")
                    # Continuar sin contexto
            
            # Ejecutar agente Agno Avatar
            try:
                response = self.agent.run(enhanced_query)
                
                if response is None:
                    return "‚ö†Ô∏è No se pudo generar respuesta Avatar"
                
                result = str(response)
                
                # üîß GUARDAR M√âTRICAS AVATAR
                if POSTGRES_AVAILABLE and session_id:
                    try:
                        save_performance_metric_simple(session_id, "corva_agno_avatar", 0.0, True)
                        print("‚úÖ M√©tricas Avatar guardadas")
                    except Exception as metrics_error:
                        print(f"‚ö†Ô∏è Error guardando m√©tricas Avatar: {metrics_error}")
                
                print(f"‚úÖ RESPUESTA AVATAR: {len(result)} chars")
                return result
                
            except Exception as agent_error:
                print(f"‚ùå Error en agente Avatar: {agent_error}")
                return f"Error ejecutando agente Avatar: {str(agent_error)}"
            
        except Exception as e:
            print(f"‚ùå Error general Avatar: {e}")
            return f"Error procesando Avatar: {str(e)}"


# üîß INTERFAZ DE COMPATIBILIDAD AVATAR
_corva_agent_avatar_instance = None

def get_corva_agent() -> CorvaAgnoAgent:
    """Obtiene instancia singleton del agente Avatar"""
    global _corva_agent_avatar_instance
    
    if _corva_agent_avatar_instance is None:
        print("üîÑ Inicializando agente Corva Avatar completo...")
        _corva_agent_avatar_instance = CorvaAgnoAgent()
        print(f"‚úÖ Agente Corva Avatar completo inicializado")
    
    return _corva_agent_avatar_instance

def corva_api_query_agnostic(user_query: str) -> str:
    """
    üöÄ FUNCI√ìN PRINCIPAL AVATAR - Interfaz compatible con sistema Avatar
    
    INTEGRACI√ìN AVATAR COMPLETA:
    - Manejo de errores robusto
    - Fallback al m√©todo original
    - Compatible con toda la infraestructura Avatar
    """
    try:
        print('üöÄ INICIANDO corva_api_query_agnostic AVATAR')
        
        if not user_query or not str(user_query).strip():
            return "‚ö†Ô∏è Consulta vac√≠a recibida."
        
        clean_query = str(user_query).strip()
        print(f"üîç AVATAR - Query validada: '{clean_query}'")
        
        agent = get_corva_agent()
        return agent.process_query(clean_query)
        
    except Exception as e:
        error_msg = str(e)
        print(f"‚ùå ERROR PRINCIPAL AVATAR: {error_msg}")
        
        # Fallback al m√©todo original si est√° disponible
        try:
            from src.corva_tool_avatar import corva_api_query as original_corva_api_query
            print("üîÑ Usando m√©todo original Avatar como fallback...")
            return original_corva_api_query(user_query)
        except Exception as fallback_error:
            return f"‚ö†Ô∏è Error en agente Avatar y m√©todo original: {str(fallback_error)}"


# üîß FUNCIONES DE DIAGN√ìSTICO AVATAR
def diagnose_avatar_environment():
    """
    Diagnostica el estado del entorno Avatar espec√≠ficamente
    """
    print("üîç DIAGN√ìSTICO DEL ENTORNO AVATAR CORVA")
    print("=" * 60)
    
    # 1. Verificar importaci√≥n de Agno
    try:
        from agno.agent import Agent
        print("‚úÖ Agno importable: S√ç")
    except ImportError:
        print("‚ùå Agno importable: NO")
    
    # 2. Verificar variables de entorno Avatar
    print("\nüîß Variables de entorno Avatar:")
    avatar_vars = [
        "APIM_AUTH_CREDENTIAL",
        "AZURE_OPENAI_API_KEY", 
        "AZURE_OPENAI_ENDPOINT",
        "AZURE_OPENAI_DEPLOYMENT_NAME",  # ‚Üê Variable Avatar est√°ndar
        "API_VERSION"  # ‚Üê Variable Avatar est√°ndar
    ]
    
    for var in avatar_vars:
        value = os.getenv(var)
        if value:
            masked_value = value[:10] + "..." if len(value) > 10 else value
            print(f"  ‚úÖ {var}: {masked_value}")
        else:
            print(f"  ‚ùå {var}: NO CONFIGURADA")
    
    # 3. Verificar disponibilidad Avatar completa
    is_valid, missing_vars = validate_azure_env_vars_avatar()
    if is_valid:
        print(f"\nüéØ Estado Avatar final: ‚úÖ Todas las variables est√°n configuradas")
    else:
        print(f"\nüéØ Estado Avatar final: ‚ùå Variables faltantes: {missing_vars}")
    
    # 4. Verificar integraci√≥n Avatar
    print(f"\nü§ñ Integraci√≥n Avatar:")
    print(f"  üìù Memoria disponible: {MEMORY_AVAILABLE}")
    print(f"  üóÑÔ∏è PostgreSQL disponible: {POSTGRES_AVAILABLE}")
    
    # 5. Intentar crear agente Avatar
    print(f"\nüöÄ Probando inicializaci√≥n del agente Avatar:")
    try:
        agent = CorvaAgnoAgent()
        print(f"  {agent.get_status_info()}")
    except Exception as e:
        print(f"  ‚ùå Error Avatar: {e}")

if __name__ == "__main__":
    # Ejecutar diagn√≥stico Avatar
    diagnose_avatar_environment()


"""
CORRECCIONES CR√çTICAS APLICADAS PARA AVATAR:
============================================

üîß **Variables de entorno Avatar espec√≠ficas**: 
   - AZURE_OPENAI_DEPLOYMENT_NAME (est√°ndar Avatar)
   - API_VERSION (est√°ndar Avatar)

üîß **Importaciones Avatar corregidas**:
   - src.corva_tool_avatar (ruta Avatar correcta)
   - src.langmem_functions (memoria Avatar)
   - src.postgres_integration (PostgreSQL Avatar)

üîß **Eliminaci√≥n de cache problem√°tico**:
   - NO m√°s last_asset_search que causaba dependencias
   - Tools independientes que usan matching autom√°tico

üîß **Integraci√≥n memoria Avatar completa**:
   - get_relevant_context_for_question()
   - create_enhanced_prompt_with_memory()
   - save_performance_metric_simple()

üîß **Configuraci√≥n Azure Avatar robusta**:
   - Validaci√≥n espec√≠fica para variables Avatar
   - Manejo de errores Avatar apropiado
   - Fallback a m√©todos originales Avatar

üîß **Instrucciones optimizadas para Avatar**:
   - CoT apropiado para sistema Avatar
   - Integraci√≥n con matching autom√°tico
   - Manejo de errores Avatar espec√≠fico

üîß **Funciones de diagn√≥stico Avatar**:
   - diagnose_avatar_environment()
   - validate_azure_env_vars_avatar()

RESULTADO: 
==========
Agente Avatar totalmente funcional que mantiene TODA la integraci√≥n con:
- Sistema de memoria Avatar
- PostgreSQL Avatar  
- Variables de entorno Avatar
- Estructura de proyecto Avatar
- Matching autom√°tico inteligente
- Sin dependencias de cache problem√°ticas

El agente ahora funciona independientemente pero integrado completamente con el ecosistema Avatar.
"""